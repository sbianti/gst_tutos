		GStreamer Playback
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
http://docs.gstreamer.com/display/GstSDK/Playback+tutorial+1%3A+Playbin2+usage

I) playback-1_playbin.c:
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
⋅ Utilisation + approfondie de playbin.
⋅ Récupération de la liste des metadata.
C'est un plugin, donc certains objets ne sont pas accessibles depuis core.
Il faudra parfois les redéclarer (ex: GST_PLAY_FLAG_[VIDEO|AUDIO|TEXT]).

A/
data.playbin = gst_element_factory_make("playbin", "el playbin");
	→ Une autre façon de créer un pipeline (gst_parse_launch dans basic-1_hello.c cf. HowTo-basics.txt)

B/
g_object_get(data.playbin, "flags", &flags, NULL);
  flags |= GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO;
  flags &= ~GST_PLAY_FLAG_TEXT;
g_object_set(data.playbin, "flags", flags, NULL); 
	→ Activation de l'audio et de la vidéo, mais pas des sous-titres.

C/
gst_bus_add_watch(bus, (GstBusFunc)handle_message, &data);
	→ Manière asynchrone de récupérer les messages du bus du pipeline.

d/ spécifique glib
g_io_add_watch(io_stdin, G_IO_IN, (GIOFunc)handle_keyboard, &data);
	→ chopper les évènements de stdin.

e/ gmainloop
Requis par gst_bus_add_watch(…) (et g_io_add_watch)

F/ analyze_streams() appelée par handle_message() lors d'un STATE_CHANGED
⋅ g_object_get(data->playbin, "n-video", &data->n_video, NULL);
	→ On récupère les infos contenue dans le flux analysé par la source de playbin. (get("n-video"…))

⋅ g_signal_emit_by_name(data->playbin, "get-video-tags", i, &taglist);
	→ On émet un signal de type Action (voir glib) qui est donc une sorte de fonction à appeler et qui renvoie le GstTagList associé au flux (les metadata).

⋅ gst_tag_list_get_[string](tags, GST_TAG_[AUDIO_CODEC], &str)
	→ Récupération des métadonnés.

⋅ g_object_get(data->playbin, "current-[video]", &data->current_…, NULL);
	→ trivial

G/ handle_keyboard()
⋅ g_object_set(data->playbin, "current-audio", index, NULL);
	→ voir g_io_channel_read_line() pour la réception d'une ligne de texte.


II) playback-2_sub-management.c:
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
⋅ Similaire à playback-1, mais avec gestion des sous-titres.
⇒ Semble y avoir un bug lorsqu'on charge un sous-titre en plus :
  lorsqu'on change de sous-titre, plus rien n'est affiché.


III) playback-3_short-cutting_pipeline.c:
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯


IV) playback-4_progressive_streaming.c:
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 Comment activer le cache de données téléchargées ?
 Comment en contrôler la quantité ?
 Comment conserver ce qui a été téléchargé ?

Par défaut, le flux téléchargé est conservé en mémoire dans des buffers éliminés dès qu'ils ont étés consommés. Dans ce cas, le seul moyen de faire un retour arrière est de re-télécharger ces données.

Ce n'est pas une technique très efficace pour la lecture des flux qui ne sont pas en direct.

Les media-players présentent généralement une barre affichant l'état des données téléchargées accompagnée de la position courante.

L'élément playbin permet le buffering sur disque à travers le flag booléen “download”.

A/
Idem Basic-12

B/
  …
  flags |= GST_PLAY_FLAG_DOWNLOAD;
  g_object_set (pipeline, "flags", flags, NULL);
	→ On veut stocker le flux. L'enum GstPlayFlags est déclarée dans gst-plugins-base.

C/
  g_object_set(pipeline, "ring-buffer-max-size", (guint64)400000, NULL);
	→ Limitation du tampon cyclique à 400000 octets.

D1/
  g_signal_connect(pipeline, "deep-notify::temp-location", G_CALLBACK(cb), NULL);
	→ Le signal “deep-notify” est émit par tout GstObject quand une propriété d'un élément enfant change. Ici, on veut être averti du changement du nom du fichier où stocker les données téléchargées, ce qui arrive lorsque la Queue crée ce fichier.

D2/
	→ Dans la callback, on n'a qu'à récupérer cette propriété et avec:
  g_object_set(G_OBJECT(prop_object), "temp-remove", FALSE, NULL);
	→ Lorsque le pipeline passe PAUSED à READY, le fichier qui est normalement effacé ne l'est pas.

E/ gboolean refresh_ui(CustomData *data)
  GstQuery *query = gst_query_new_buffering(GST_FORMAT_PERCENT);
	→ création d'une requête de type buffering en %

  int n = gst_query_get_n_buffering_ranges(query);
	→ récupère le nombre de buffers stockés

  for (range = 0; range < n_ranges; range++) {
    gint64 start, stop;
    gst_query_parse_nth_buffering_range(query, range, &start, &stop);
    …
	→ récupère les intervalles (en %) des segments téléchargés du flux.

  if (gst_element_query_position(data->pipeline, FORMAT, &position) &&
      GST_CLOCK_TIME_IS_VALID(position) &&
      gst_element_query_duration(data->pipeline, FORMAT, &duration) &&
      GST_CLOCK_TIME_IS_VALID(duration)) {
      …
	→ On récupère la position et la durée (en seconde), et on valide ces valeurs.


V) playback-5_color-balance.c:
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 De l'équilibrage des couleurs (luminosité, contraste, teinte et saturation).
 Comment trouver les canaux disponibles (l'un des 4 précédents) ?
 Comment les changer ?

Playbin implémente l'interface gstcolorbalance (http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-libs/html/gst-plugins-base-libs-gstcolorbalance.html). Si un de ses éléments l'implémente aussi, playbin lui transmet les commandes reçues, sinon il ajoute un élément qui l'implémente.

Le code est simple.

Fonctionnalités ajoutées: on peut donner un incrément différent de 10 points (B -34), et on peut donner la valeur exacte (H 40%).
